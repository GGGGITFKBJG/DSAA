### 371. 两整数之和
> <div
> class="content__2ebE"><p><strong>不使用</strong>运算符&nbsp;<code>+</code>
> 和&nbsp;<code>-</code>&nbsp;​​​​​​​，计算两整数&nbsp;​​​​​​​<code>a</code>&nbsp;、<code>b</code>&nbsp;​​​​​​​之和。</p>
> 
> <p><strong>示例 1:</strong></p>
> 
> <pre><strong>输入: </strong>a = 1, b = 2 
> <strong>输出: </strong>3 </pre>
> 
> <p><strong>示例 2:</strong></p>
> 
> <pre><strong>输入: </strong>a = -2, b = 3 
> <strong>输出: </strong>1</pre>
> </div></div>

解法一
```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while (b != 0) {
		    int temp = a ^ b;
		    b = ((a & b) & 0x7fffffff) << 1;//b = (a & b) << 1;
		    a = temp;
	    }
	    return a;
    }
};
```

很明显是用位运算。
1. 先使用按位异或运算符，求出两数的不进位和temp；
2. 再使用按位与运算符，求出会产生进位的位，再左移1位，即是进位；
3. 循环地对不进位和a与进位b相加，直到进位为0，返回不进位和a。
代码第6行0x7fffffff 的与运算是为了避免左移位覆盖掉符号位，每次都将符号位置0。（实测VS编译器可以不用多此一举，但是leetcode编译器好像不允许对负数左移运算）

这里需要了解一些二进制的知识，
1. 移位操作有两种，
对于无符号整数，右移运算、左移运算都是逻辑移位，统一对移出的空位补0；
而对于有符号整数，左移运算是逻辑左移（空位补0，左移会把符号位的1移掉）；而右移运算是算术移位（空位补上符号位）；
2. 为什么不用考虑符号位，原因就是负数是按补码形式存储的，可以直接像正数那样参与运算，不用单独考虑符号位（这一点VS编译器就做得很好）；
3. 按位异或运算（相同为0，不同为1），它的作用效果就是不进位的加法，所以可以用这个特点，a ^ b 就是不进位的和；
4. 按位与运算，可以把同为1的位标识出来（也就是产生进位的位），再左移1位，（进位）加到原不进位加法和上，即是答案。但是我们只有不进位加法，那就反复进行，直到进位为0；

<div style="text-align: right">   2019/05/01 13:50     </div>